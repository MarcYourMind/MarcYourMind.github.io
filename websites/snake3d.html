<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CUBE SNAKE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #020408; color: #00ff88; font-family: 'Share Tech Mono', monospace; overflow: hidden; height: 100vh; width: 100vw; }
  #canvas-container { position: fixed; inset: 0; z-index: 0; }
  canvas { display: block; }
  #ui { position: fixed; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 24px 32px; }
  #header { display: flex; align-items: center; justify-content: space-between; }
  #title { font-family: 'Orbitron', monospace; font-size: 28px; font-weight: 900; letter-spacing: 0.2em; color: #00ff88; text-shadow: 0 0 20px #00ff8866, 0 0 40px #00ff8833; }
  #score-panel { display: flex; gap: 40px; }
  .stat { display: flex; flex-direction: column; align-items: flex-end; }
  .stat-label { font-size: 10px; letter-spacing: 0.3em; color: #00ff8866; text-transform: uppercase; }
  .stat-value { font-family: 'Orbitron', monospace; font-size: 28px; font-weight: 700; color: #00ff88; text-shadow: 0 0 15px #00ff8888; line-height: 1; }
  #footer { display: flex; justify-content: center; gap: 24px; }
  .key-hint { font-size: 11px; letter-spacing: 0.15em; color: #00ff8844; text-transform: uppercase; }
  .key-hint kbd { display: inline-block; border: 1px solid #00ff8844; border-radius: 3px; padding: 1px 6px; margin: 0 2px; color: #00ff8866; }
  #overlay { position: fixed; inset: 0; z-index: 20; display: flex; align-items: center; justify-content: center; background: rgba(2,4,8,0.85); backdrop-filter: blur(4px); transition: opacity 0.4s; }
  #overlay.hidden { opacity: 0; pointer-events: none; }
  #menu { text-align: center; border: 1px solid #00ff8833; padding: 48px 64px; background: rgba(0,255,136,0.02); box-shadow: 0 0 60px #00ff8811, inset 0 0 60px #00ff8805; }
  #menu h1 { font-family: 'Orbitron', monospace; font-size: 52px; font-weight: 900; letter-spacing: 0.3em; color: #00ff88; text-shadow: 0 0 30px #00ff8888, 0 0 60px #00ff8844; margin-bottom: 8px; }
  #menu .subtitle { font-size: 13px; letter-spacing: 0.4em; color: #00ff8866; margin-bottom: 40px; text-transform: uppercase; }
  #menu-score { font-family: 'Orbitron', monospace; font-size: 18px; color: #00ff8888; margin-bottom: 40px; letter-spacing: 0.15em; min-height: 28px; }
  #start-btn { pointer-events: all; cursor: pointer; background: transparent; border: 1px solid #00ff88; color: #00ff88; font-family: 'Orbitron', monospace; font-size: 14px; font-weight: 700; letter-spacing: 0.3em; padding: 16px 48px; text-transform: uppercase; transition: all 0.2s; box-shadow: 0 0 20px #00ff8833; }
  #start-btn:hover { background: #00ff8811; box-shadow: 0 0 40px #00ff8866; transform: scale(1.02); }
  #face-indicator { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 10; pointer-events: none; display: flex; gap: 8px; }
  .face-dot { width: 8px; height: 8px; border-radius: 50%; border: 1px solid #00ff8844; background: transparent; transition: all 0.3s; }
  .face-dot.active { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
  body::after { content: ''; position: fixed; inset: 0; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px); pointer-events: none; z-index: 100; }
  #speed-bar-container { position: fixed; top: 80px; right: 32px; z-index: 10; pointer-events: none; display: flex; flex-direction: column; align-items: flex-end; gap: 6px; }
  #speed-label { font-size: 9px; letter-spacing: 0.3em; color: #00ff8866; }
  #speed-bar { width: 6px; height: 80px; border: 1px solid #00ff8833; position: relative; overflow: hidden; }
  #speed-fill { position: absolute; bottom: 0; width: 100%; background: #00ff88; box-shadow: 0 0 8px #00ff88; transition: height 0.5s; }
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="ui">
  <div id="header">
    <div id="title">CUBE SNAKE</div>
    <div id="score-panel">
      <div class="stat"><span class="stat-label">Score</span><span class="stat-value" id="score-display">0</span></div>
      <div class="stat"><span class="stat-label">Best</span><span class="stat-value" id="best-display">0</span></div>
    </div>
  </div>
  <div id="footer">
    <span class="key-hint"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or <kbd>↑</kbd><kbd>←</kbd><kbd>↓</kbd><kbd>→</kbd> Move</span>
    <span class="key-hint"><kbd>R</kbd> Restart</span>
    <span class="key-hint"><kbd>Drag</kbd> Override camera</span>
  </div>
</div>
<div id="speed-bar-container">
  <div id="speed-label">SPEED</div>
  <div id="speed-bar"><div id="speed-fill"></div></div>
</div>
<div id="face-indicator">
  <div class="face-dot" id="dot-0"></div><div class="face-dot" id="dot-1"></div>
  <div class="face-dot" id="dot-2"></div><div class="face-dot" id="dot-3"></div>
  <div class="face-dot" id="dot-4"></div><div class="face-dot" id="dot-5"></div>
</div>
<div id="overlay">
  <div id="menu">
    <h1>CUBE<br>SNAKE</h1>
    <div class="subtitle">Navigate the void &mdash; 3D Surface Mode</div>
    <div id="menu-score"></div>
    <button id="start-btn">INITIALIZE</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// CUBE SNAKE — snake moves on all 6 faces of a 3D cube
// ============================================================

const GRID = 9;           // cells per face edge (must be odd for clean center)
const HALF = (GRID-1)/2;  // = 4 (center grid coord)
const CELL = 1.0;
const CUBE_SIZE = GRID * CELL; // = 9

// ---- Face definitions ----
// Each face has: normal (n), right (r), up (u) vectors in world space.
// Grid coord gx goes along r, gy goes along u, both from 0..GRID-1.
// World position = n*(CUBE_SIZE/2) + r*(gx-HALF)*CELL + u*(gy-HALF)*CELL
const FACES = [
  { id:0, n:new THREE.Vector3( 0, 0, 1), r:new THREE.Vector3( 1, 0, 0), u:new THREE.Vector3(0, 1, 0) }, // +Z front
  { id:1, n:new THREE.Vector3( 0, 0,-1), r:new THREE.Vector3(-1, 0, 0), u:new THREE.Vector3(0, 1, 0) }, // -Z back
  { id:2, n:new THREE.Vector3( 1, 0, 0), r:new THREE.Vector3( 0, 0,-1), u:new THREE.Vector3(0, 1, 0) }, // +X right
  { id:3, n:new THREE.Vector3(-1, 0, 0), r:new THREE.Vector3( 0, 0, 1), u:new THREE.Vector3(0, 1, 0) }, // -X left
  { id:4, n:new THREE.Vector3( 0, 1, 0), r:new THREE.Vector3( 1, 0, 0), u:new THREE.Vector3(0, 0,-1) }, // +Y top
  { id:5, n:new THREE.Vector3( 0,-1, 0), r:new THREE.Vector3( 1, 0, 0), u:new THREE.Vector3(0, 0, 1) }, // -Y bottom
];

// ---- Face transition table ----
// Derived analytically from cube geometry (verified by Python).
// TRANS[srcFace][exitEdge] = { dest, entryEdge, flip }
//
// Exit edges:  0=+r(right), 1=+u(up), 2=-r(left), 3=-u(down)
// Entry edges: same encoding — which edge of the dest face we arrive at.
//   entry=0 (from right)  => new dir: dr=-1, du=0
//   entry=1 (from top)    => new dir: dr=0,  du=-1
//   entry=2 (from left)   => new dir: dr=1,  du=0
//   entry=3 (from bottom) => new dir: dr=0,  du=1
//
// flip=true means the parallel coordinate is mirrored: p -> (GRID-1-p)
// The "parallel" coord is the one perpendicular to movement:
//   exit edge 0 or 2 (moving in r): parallel = gy
//   exit edge 1 or 3 (moving in u): parallel = gx

const TRANS = [
  // Face 0: +Z front
  [ {dest:2, entry:2, flip:false}, {dest:4, entry:3, flip:false}, {dest:3, entry:0, flip:false}, {dest:5, entry:1, flip:false} ],
  // Face 1: -Z back
  [ {dest:3, entry:2, flip:false}, {dest:4, entry:1, flip:true},  {dest:2, entry:0, flip:false}, {dest:5, entry:3, flip:true}  ],
  // Face 2: +X right
  [ {dest:1, entry:2, flip:false}, {dest:4, entry:0, flip:false}, {dest:0, entry:0, flip:false}, {dest:5, entry:0, flip:true}  ],
  // Face 3: -X left
  [ {dest:0, entry:2, flip:false}, {dest:4, entry:2, flip:true},  {dest:1, entry:0, flip:false}, {dest:5, entry:2, flip:false} ],
  // Face 4: +Y top
  [ {dest:2, entry:1, flip:false}, {dest:1, entry:1, flip:true},  {dest:3, entry:1, flip:true},  {dest:0, entry:1, flip:false} ],
  // Face 5: -Y bottom
  [ {dest:2, entry:3, flip:true},  {dest:0, entry:3, flip:false}, {dest:3, entry:3, flip:false}, {dest:1, entry:3, flip:true}  ],
];

// Direction from entry edge: what direction does the snake move on the new face?
function entryEdgeToDir(entry) {
  // entry=0 arrived from right  => move left  (dr=-1)
  // entry=1 arrived from top    => move down  (du=-1)
  // entry=2 arrived from left   => move right (dr=1)
  // entry=3 arrived from bottom => move up    (du=1)
  return [[{dr:-1,du:0},{dr:0,du:-1},{dr:1,du:0},{dr:0,du:1}][entry]][0];
}

// ---- Three.js setup ----
const container = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020408);
scene.fog = new THREE.FogExp2(0x020408, 0.018);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 200);

const ambientLight = new THREE.AmbientLight(0x00ff88, 0.15);
scene.add(ambientLight);
const pointLight = new THREE.PointLight(0x00ff88, 1.5, 60);
pointLight.position.set(10, 15, 10);
scene.add(pointLight);
const pointLight2 = new THREE.PointLight(0x0088ff, 0.8, 60);
pointLight2.position.set(-12, -10, -8);
scene.add(pointLight2);

// ---- Cube visual ----
const cubeGroup = new THREE.Group();
scene.add(cubeGroup);

const facePositions = [
  { pos:[0,0,CUBE_SIZE/2],  rot:[0,0,0] },
  { pos:[0,0,-CUBE_SIZE/2], rot:[0,Math.PI,0] },
  { pos:[CUBE_SIZE/2,0,0],  rot:[0,Math.PI/2,0] },
  { pos:[-CUBE_SIZE/2,0,0], rot:[0,-Math.PI/2,0] },
  { pos:[0,CUBE_SIZE/2,0],  rot:[-Math.PI/2,0,0] },
  { pos:[0,-CUBE_SIZE/2,0], rot:[Math.PI/2,0,0] },
];

// Transparent face panels
const faceGeo = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
facePositions.forEach(({pos, rot}) => {
  const m = new THREE.Mesh(faceGeo, new THREE.MeshStandardMaterial({
    color:0x00ff88, transparent:true, opacity:0.04, side:THREE.FrontSide, roughness:0.8, metalness:0.2
  }));
  m.position.set(...pos); m.rotation.set(...rot);
  cubeGroup.add(m);
});

// Grid lines on each face
FACES.forEach(face => {
  const mat = new THREE.LineBasicMaterial({ color:0x00ff88, transparent:true, opacity:0.12 });
  const group = new THREE.Group();
  const hs = CUBE_SIZE/2;
  for (let i = 0; i <= GRID; i++) {
    const t = -hs + i * CELL;
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(t,-hs,0), new THREE.Vector3(t,hs,0)]), mat));
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-hs,t,0), new THREE.Vector3(hs,t,0)]), mat));
  }
  const fp = facePositions[face.id];
  group.position.set(...fp.pos); group.rotation.set(...fp.rot);
  group.position.addScaledVector(face.n, 0.02);
  cubeGroup.add(group);
});

// Wireframe edges
const edgeGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE));
const edgeMat = new THREE.LineBasicMaterial({ color:0x00ff88, transparent:true, opacity:0.5 });
cubeGroup.add(new THREE.LineSegments(edgeGeo, edgeMat));

// ---- Camera tracking ----
const camDir = new THREE.Vector3(0.6, 0.5, 0.8).normalize();
const camDirTarget = camDir.clone();
let isDragging = false, lastMX = 0, lastMY = 0;
let dragOverride = false, dragOverrideTimer = null;

function camDirToAngles(v) { return { rotX: Math.asin(Math.max(-1,Math.min(1,v.y))), rotY: Math.atan2(v.x, v.z) }; }
function anglesToCamDir(rotX, rotY) {
  return new THREE.Vector3(Math.sin(rotY)*Math.cos(rotX), Math.sin(rotX), Math.cos(rotY)*Math.cos(rotX));
}
let dragAngles = camDirToAngles(camDir);

function startDrag(mx, my) {
  isDragging = true; lastMX = mx; lastMY = my;
  dragAngles = camDirToAngles(camDir);
}
function moveDrag(mx, my) {
  if (!isDragging) return;
  dragOverride = true; clearTimeout(dragOverrideTimer);
  dragAngles.rotY += (mx - lastMX) * 0.008;
  dragAngles.rotX += (my - lastMY) * 0.008;
  dragAngles.rotX = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, dragAngles.rotX));
  lastMX = mx; lastMY = my;
  camDirTarget.copy(anglesToCamDir(dragAngles.rotX, dragAngles.rotY));
}
function endDrag() {
  isDragging = false;
  clearTimeout(dragOverrideTimer);
  dragOverrideTimer = setTimeout(() => { dragOverride = false; }, 2000);
}

renderer.domElement.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
window.addEventListener('mouseup', endDrag);
renderer.domElement.addEventListener('touchstart', e => startDrag(e.touches[0].clientX, e.touches[0].clientY), {passive:true});
window.addEventListener('touchmove', e => { if(isDragging) moveDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:true});
window.addEventListener('touchend', endDrag);

function setCameraTargetToFace(faceId) {
  if (dragOverride) return;
  const n = FACES[faceId].n;
  const upHint = new THREE.Vector3(0.15, 0.25, 0.15);
  camDirTarget.copy(n.clone().add(upHint).normalize());
}

// ---- Cell → world position ----
function cellToWorld(face, gx, gy) {
  const hs = CUBE_SIZE / 2;
  return new THREE.Vector3()
    .addScaledVector(face.n, hs + 0.01)
    .addScaledVector(face.r, (gx - HALF) * CELL)
    .addScaledVector(face.u, (gy - HALF) * CELL);
}

// ---- Snake meshes ----
const snakeMeshes = [];
const segGeo = new THREE.BoxGeometry(CELL*0.8, CELL*0.8, CELL*0.8);
const headMat = new THREE.MeshStandardMaterial({ color:0x00ff88, emissive:0x00ff88, emissiveIntensity:0.6, roughness:0.3, metalness:0.5 });
const bodyMat = new THREE.MeshStandardMaterial({ color:0x00cc66, emissive:0x00cc66, emissiveIntensity:0.2, roughness:0.5, metalness:0.3, transparent:true, opacity:0.9 });

function getOrCreateMesh(index, isHead) {
  if (!snakeMeshes[index]) {
    snakeMeshes[index] = new THREE.Mesh(segGeo, isHead ? headMat : bodyMat.clone());
    cubeGroup.add(snakeMeshes[index]);
  }
  snakeMeshes[index].visible = true;
  return snakeMeshes[index];
}

function updateMeshes() {
  snakeMeshes.forEach(m => { if(m) m.visible = false; });
  snake.forEach((seg, i) => {
    const mesh = getOrCreateMesh(i, i === 0);
    const wp = cellToWorld(FACES[seg.face], seg.gx, seg.gy);
    mesh.position.copy(wp);
    mesh.lookAt(wp.clone().add(FACES[seg.face].n));
  });
}

// ---- Food mesh ----
const foodGeo = new THREE.OctahedronGeometry(CELL*0.45, 0);
const foodMat = new THREE.MeshStandardMaterial({ color:0xff3366, emissive:0xff3366, emissiveIntensity:0.8, roughness:0.2, metalness:0.6 });
let foodMesh = null;
const foodLight = new THREE.PointLight(0xff3366, 1.5, 8);

function placeFoodMesh() {
  if (!foodMesh) { foodMesh = new THREE.Mesh(foodGeo, foodMat); cubeGroup.add(foodMesh); cubeGroup.add(foodLight); }
  foodMesh.visible = true;
  const wp = cellToWorld(FACES[food.face], food.gx, food.gy);
  foodMesh.position.copy(wp);
  foodLight.position.copy(wp);
}

// ---- Game state ----
let snake = [];           // array of {face, gx, gy}, head at index 0
let dir = {dr:1, du:0};  // current movement direction on current face
let nextDir = null;       // buffered player input
let food = null;
let score = 0, best = 0;
let gameRunning = false;

// ---- Timing (setTimeout-based to avoid interval reset on speed change) ----
const BASE_SPEED = 300;
const MIN_SPEED  = 120;
const SPEED_STEP = 10;
let currentSpeed = BASE_SPEED;
let stepTimeout = null;

function scheduleNextStep() {
  if (!gameRunning) return;
  stepTimeout = setTimeout(() => {
    stepSnake();
    scheduleNextStep();
  }, currentSpeed);
}

// ---- Core step function ----
function stepSnake() {
  if (!gameRunning) return;

  // Apply buffered direction (never allow 180° reversal)
  if (nextDir) {
    if (!(nextDir.dr === -dir.dr && nextDir.du === -dir.du)) {
      dir = nextDir;
    }
    nextDir = null;
  }

  const head = snake[0];
  let { face: nface, gx: ngx, gy: ngy } = head;
  let { dr: ndr, du: ndu } = dir;

  ngx += ndr;
  ngy += ndu;

  // ---- Face transition ----
  if (ngx < 0 || ngx >= GRID || ngy < 0 || ngy >= GRID) {
    // Which exit edge did we cross?
    // exit 0: ngx >= GRID (moved +r)
    // exit 1: ngy >= GRID (moved +u)
    // exit 2: ngx < 0    (moved -r)
    // exit 3: ngy < 0    (moved -u)
    let exitEdge;
    if      (ngx >= GRID) exitEdge = 0;
    else if (ngy >= GRID) exitEdge = 1;
    else if (ngx < 0)     exitEdge = 2;
    else                  exitEdge = 3;

    const { dest, entry, flip } = TRANS[nface][exitEdge];

    // The parallel coordinate: the axis NOT in the movement direction
    // exit 0 or 2 (moved in r): parallel coord is gy (head.gy)
    // exit 1 or 3 (moved in u): parallel coord is gx (head.gx)
    let p = (exitEdge === 0 || exitEdge === 2) ? head.gy : head.gx;
    if (flip) p = (GRID - 1) - p;

    // New dir from entry edge
    const newDir = entryEdgeToDir(entry);
    ndr = newDir.dr;
    ndu = newDir.du;

    // Place new head at the entry edge on the dest face
    // entry 0 (from right):  ngx=GRID-1, ngy=p
    // entry 1 (from top):    ngx=p, ngy=GRID-1
    // entry 2 (from left):   ngx=0, ngy=p
    // entry 3 (from bottom): ngx=p, ngy=0
    if      (entry === 0) { ngx = GRID-1; ngy = p; }
    else if (entry === 1) { ngx = p; ngy = GRID-1; }
    else if (entry === 2) { ngx = 0; ngy = p; }
    else                  { ngx = p; ngy = 0; }

    nface = dest;
    dir = { dr: ndr, du: ndu };
    // Note: nextDir is NOT cleared here — preserve any input buffered during transition
  }

  // ---- Self-collision check ----
  // Exclude the tail segment (index snake.length-1) because it will move away this step
  for (let i = 0; i < snake.length - 1; i++) {
    if (snake[i].face === nface && snake[i].gx === ngx && snake[i].gy === ngy) {
      endGame(); return;
    }
  }

  // ---- Move ----
  snake.unshift({ face: nface, gx: ngx, gy: ngy });

  const ateFood = food && food.face === nface && food.gx === ngx && food.gy === ngy;
  if (!ateFood) {
    snake.pop();
  } else {
    score++;
    document.getElementById('score-display').textContent = score;
    const newSpeed = Math.max(MIN_SPEED, BASE_SPEED - score * SPEED_STEP);
    if (newSpeed !== currentSpeed) {
      currentSpeed = newSpeed;
      const pct = (BASE_SPEED - currentSpeed) / (BASE_SPEED - MIN_SPEED) * 100;
      document.getElementById('speed-fill').style.height = pct + '%';
      // Don't reset the timeout — speed applies on next scheduleNextStep call
    }
    spawnFood();
  }

  updateMeshes();
  // Update face indicator + camera
  for (let i = 0; i < 6; i++) document.getElementById('dot-'+i).classList.toggle('active', i === nface);
  setCameraTargetToFace(nface);
}

// ---- Food ----
function spawnFood() {
  const empty = [];
  for (let f = 0; f < 6; f++)
    for (let gx = 0; gx < GRID; gx++)
      for (let gy = 0; gy < GRID; gy++)
        if (!snake.some(s => s.face===f && s.gx===gx && s.gy===gy))
          empty.push({face:f, gx, gy});
  if (!empty.length) { endGame(); return; }
  food = empty[Math.floor(Math.random() * empty.length)];
  placeFoodMesh();
}

// ---- Game lifecycle ----
function initGame() {
  snakeMeshes.forEach(m => { if(m) m.visible=false; });
  snake = [{ face:0, gx:HALF, gy:HALF }];
  dir = { dr:1, du:0 };
  nextDir = null;
  score = 0;
  currentSpeed = BASE_SPEED;
  document.getElementById('score-display').textContent = 0;
  document.getElementById('speed-fill').style.height = '0%';
  spawnFood();
  updateMeshes();
  setCameraTargetToFace(0);
  gameRunning = true;
  scheduleNextStep();
}

function endGame() {
  gameRunning = false;
  clearTimeout(stepTimeout);
  if (score > best) { best = score; document.getElementById('best-display').textContent = best; }
  document.getElementById('menu-score').textContent = score > 0 ? `SCORE: ${score}` : '';
  document.getElementById('start-btn').textContent = score > 0 ? 'PLAY AGAIN' : 'INITIALIZE';
  document.getElementById('overlay').classList.remove('hidden');
}

function startGame() {
  document.getElementById('overlay').classList.add('hidden');
  clearTimeout(stepTimeout);
  initGame();
}

// ---- Input ----
function tryTurn(dr, du) {
  // Allow queueing any turn except 180°. Check against current dir (not nextDir)
  // so rapid inputs don't chain a 180° through an intermediate.
  if (dr === -dir.dr && du === -dir.du) return;
  nextDir = { dr, du };
}

window.addEventListener('keydown', e => {
  switch(e.key) {
    case 'ArrowUp':    case 'w': case 'W': e.preventDefault(); tryTurn(0, 1);  break;
    case 'ArrowDown':  case 's': case 'S': e.preventDefault(); tryTurn(0, -1); break;
    case 'ArrowLeft':  case 'a': case 'A': e.preventDefault(); tryTurn(-1, 0); break;
    case 'ArrowRight': case 'd': case 'D': e.preventDefault(); tryTurn(1, 0);  break;
    case 'r': case 'R': if(gameRunning) endGame(); else startGame(); break;
  }
});

document.getElementById('start-btn').addEventListener('click', startGame);

// Touch swipe
let touchStartX, touchStartY;
renderer.domElement.addEventListener('touchstart', e => { touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }, {passive:true});
renderer.domElement.addEventListener('touchend', e => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
  if (Math.abs(dx) > Math.abs(dy)) tryTurn(dx > 0 ? 1 : -1, 0);
  else tryTurn(0, dy > 0 ? -1 : 1);
}, {passive:true});

// ---- Render loop ----
let lastTime = 0;
function animate(time) {
  requestAnimationFrame(animate);
  const dt = Math.min((time - lastTime) * 0.001, 0.1);
  lastTime = time;

  // Smooth camera
  const lerpSpeed = isDragging ? 20 : (dragOverride ? 5 : 2.5);
  camDir.lerp(camDirTarget, Math.min(1, lerpSpeed * dt)).normalize();

  // Food spin + light pulse
  if (foodMesh && foodMesh.visible) {
    foodMesh.rotation.x += dt * 2.5;
    foodMesh.rotation.y += dt * 1.8;
    foodLight.intensity = 1.2 + 0.5 * Math.sin(time * 0.003);
  }

  // Head pulse
  headMat.emissiveIntensity = 0.6 + 0.2 * Math.sin(time * 0.008);

  // Edge pulse
  edgeMat.opacity = 0.35 + 0.15 * Math.sin(time * 0.001);

  // Gentle auto-rotate on menu
  if (!gameRunning && !isDragging) {
    const a = camDirToAngles(camDirTarget);
    a.rotY += dt * 0.15;
    camDirTarget.copy(anglesToCamDir(a.rotX, a.rotY));
  }

  // Position camera
  camera.position.copy(camDir).multiplyScalar(22);
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate(0);
</script>
</body>
</html>
